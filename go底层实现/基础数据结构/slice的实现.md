# Slice的底层实现

在go语言中，切片的使用是很广泛的，它其实就是一个动态的数组，然后具有一定的操作下面对一些操作进行讲解。

在生成切片的时候， 不像数组是类型加大小一起构成的数组类型，切片只有一个类型就可以决定类型，在编译的时候，我们就可以拿到类型，这样可以在后面运行的时候得到切片的类型。

## 数据结构

切片的数据结构如下：

```go
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```

上面就是切片的数据结构：

* Data指向底层数字的指针
* Len记录切片的长度
* Cap记录切片的容量

切片的底层本质还是数组，只是上面多了一层的抽象层。

## 初始化

切片的初始化，大致分为三种：

* 使用slice[:]，通过下标的方式获得数组或者切片的一部分
* 字面量 []int{}
* 使用关键字make

三种方式中，第一种是最接近底层实现的一种。

### 使用slice[:]

使用slice[:]是最接近底层实现的一个方式，首先我们会创建一个slice的数据结构，然后根据条件进行创建。传入底层数组指针，类型，长度，容量，然后进行创建，这里需要注意的就是我们没有进行数组的拷贝，而是记录的数组的指针，所以这里我们修改元素，底层数组的元素也会改变。

### 字面量 []int{}

使用字面量的创建，我们首先会创建一个数组，然后这里会根据字面量进行大小的判断，然后创建一个数组，然后在使用通过下标的方式获得数组或者切片的一部分。所以我们说第一种方式是最接近底层实现的方式。

```go
var vstat [3]int
vstat[0] = 1
vstat[1] = 2
vstat[2] = 3
var vauto *[3]int = new([3]int)
*vauto = vstat
slice := vauto[:]
```

1. 根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；
2. 将这些字面量元素存储到初始化的数组中；
3. 创建一个同样指向 `[3]int` 类型的数组指针；
4. 将静态存储区的数组 `vstat` 赋值给 `vauto` 指针所在的地址；
5. 通过 `[:]` 操作获取一个底层使用 `vauto` 的切片；

### 使用关键字

使用关键字创建切片，在这里相对来说会麻烦一点，因为要进行判断，长度和容量的关系，然后计算内存空间的大小，进行内存空间的申请，进行创建。遇见下面的错误就会直接报错：

1. 内存空间的大小发生了溢出；
2. 申请的内存大于最大可分配的内存；
3. 传入的长度小于 0 或者长度大于容量；

然后等到一切都完成后，就会创建切片的数据结构。

## 扩容机制

在切片中最重要的就是这个扩容机制，当所需的空间大于了切片的容量的时候，我们就会进行扩容，然后扩容中关键的几个地方：

1. 如果期望容量大于当前容量的两倍就会使用期望容量；
2. 如果当前切片的长度小于 1024 就会将容量翻倍；
3. 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；

上面最后产生的是一个大致的大小，数组中元素所占的字节大小为 1、8 或者 2 的倍数时，运行时会使用如下所示的代码对齐内存。取整时会使用 [`runtime.class_to_size`](https://draveness.me/golang/tree/runtime.class_to_size)数组，使用该数组中的整数可以提高内存的分配效率并减少碎片

```go
var class_to_size = [_NumSizeClasses]uint16{
    0,
    8,
    16,
    32,
    48,
    64,
    80,
    ...,
}
```

